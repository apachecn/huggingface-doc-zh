# Stable Diffusion XL

> 译者：[片刻小哥哥](https://github.com/jiangzhonglian)
>
> 项目地址：<https://huggingface.apachecn.org/docs/diffusers/api/pipelines/stable_diffusion/stable_diffusion_xl>
>
> 原始地址：<https://huggingface.co/docs/diffusers/api/pipelines/stable_diffusion/stable_diffusion_xl>



 Stable Diffusion XL (SDXL) was proposed in
 [SDXL: Improving Latent Diffusion Models for High-Resolution Image Synthesis](https://huggingface.co/papers/2307.01952) 
 by Dustin Podell, Zion English, Kyle Lacey, Andreas Blattmann, Tim Dockhorn, Jonas Müller, Joe Penna, and Robin Rombach.
 



 The abstract from the paper is:
 



*We present SDXL, a latent diffusion model for text-to-image synthesis. Compared to previous versions of Stable Diffusion, SDXL leverages a three times larger UNet backbone: The increase of model parameters is mainly due to more attention blocks and a larger cross-attention context as SDXL uses a second text encoder. We design multiple novel conditioning schemes and train SDXL on multiple aspect ratios. We also introduce a refinement model which is used to improve the visual fidelity of samples generated by SDXL using a post-hoc image-to-image technique. We demonstrate that SDXL shows drastically improved performance compared the previous versions of Stable Diffusion and achieves results competitive with those of black-box state-of-the-art image generators.* 


## Tips



* Using SDXL with a DPM++ scheduler for less than 50 steps is known to produce
 [visual artifacts](https://github.com/huggingface/diffusers/issues/5433) 
 because the solver becomes numerically unstable. To fix this issue, take a look at this
 [PR](https://github.com/huggingface/diffusers/pull/5541) 
 which recommends for ODE/SDE solvers:
	+ set
	 `use_karras_sigmas=True` 
	 or
	 `lu_lambdas=True` 
	 to improve image quality
	+ set
	 `euler_at_final=True` 
	 if you’re using a solver with uniform step sizes (DPM++2M or DPM++2M SDE)
* Most SDXL checkpoints work best with an image size of 1024x1024. Image sizes of 768x768 and 512x512 are also supported, but the results aren’t as good. Anything below 512x512 is not recommended and likely won’t for for default checkpoints like
 [stabilityai/stable-diffusion-xl-base-1.0](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0) 
.
* SDXL can pass a different prompt for each of the text encoders it was trained on. We can even pass different parts of the same prompt to the text encoders.
* SDXL output images can be improved by making use of a refiner model in an image-to-image setting.
* SDXL offers
 `negative_original_size` 
 ,
 `negative_crops_coords_top_left` 
 , and
 `negative_target_size` 
 to negatively condition the model on image resolution and cropping parameters.




 To learn how to use SDXL for various tasks, how to optimize performance, and other usage examples, take a look at the
 [Stable Diffusion XL](../../../using-diffusers/sdxl) 
 guide.
 



 Check out the
 [Stability AI](https://huggingface.co/stabilityai) 
 Hub organization for the official base and refiner model checkpoints!
 


## StableDiffusionXLPipeline




### 




 class
 

 diffusers.
 

 StableDiffusionXLPipeline




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L96)



 (
 


 vae
 
 : AutoencoderKL
 




 text\_encoder
 
 : CLIPTextModel
 




 text\_encoder\_2
 
 : CLIPTextModelWithProjection
 




 tokenizer
 
 : CLIPTokenizer
 




 tokenizer\_2
 
 : CLIPTokenizer
 




 unet
 
 : UNet2DConditionModel
 




 scheduler
 
 : KarrasDiffusionSchedulers
 




 force\_zeros\_for\_empty\_prompt
 
 : bool = True
 




 add\_watermarker
 
 : typing.Optional[bool] = None
 



 )
 


 Parameters
 




* **vae** 
 (
 [AutoencoderKL](/docs/diffusers/v0.23.0/en/api/models/autoencoderkl#diffusers.AutoencoderKL) 
 ) —
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.
* **text\_encoder** 
 (
 `CLIPTextModel` 
 ) —
Frozen text-encoder. Stable Diffusion XL uses the text portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel) 
 , specifically
the
 [clip-vit-large-patch14](https://huggingface.co/openai/clip-vit-large-patch14) 
 variant.
* **text\_encoder\_2** 
 (
 `CLIPTextModelWithProjection` 
 ) —
Second frozen text-encoder. Stable Diffusion XL uses the text and pool portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModelWithProjection) 
 ,
specifically the
 [laion/CLIP-ViT-bigG-14-laion2B-39B-b160k](https://huggingface.co/laion/CLIP-ViT-bigG-14-laion2B-39B-b160k) 
 variant.
* **tokenizer** 
 (
 `CLIPTokenizer` 
 ) —
Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **tokenizer\_2** 
 (
 `CLIPTokenizer` 
 ) —
Second Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **unet** 
 (
 [UNet2DConditionModel](/docs/diffusers/v0.23.0/en/api/models/unet2d-cond#diffusers.UNet2DConditionModel) 
 ) — Conditional U-Net architecture to denoise the encoded image latents.
* **scheduler** 
 (
 [SchedulerMixin](/docs/diffusers/v0.23.0/en/api/schedulers/overview#diffusers.SchedulerMixin) 
 ) —
A scheduler to be used in combination with
 `unet` 
 to denoise the encoded image latents. Can be one of
 [DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 ,
 [LMSDiscreteScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/lms_discrete#diffusers.LMSDiscreteScheduler) 
 , or
 [PNDMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/pndm#diffusers.PNDMScheduler) 
.
* **force\_zeros\_for\_empty\_prompt** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `"True"` 
 ) —
Whether the negative prompt embeddings shall be forced to always be set to 0. Also see the config of
 `stabilityai/stable-diffusion-xl-base-1-0` 
.
* **add\_watermarker** 
 (
 `bool` 
 ,
 *optional* 
 ) —
Whether to use the
 [invisible\_watermark library](https://github.com/ShieldMnt/invisible-watermark/) 
 to
watermark output images. If not defined, it will default to True if the package is installed, otherwise no
watermarker will be used.


 Pipeline for text-to-image generation using Stable Diffusion XL.
 



 This model inherits from
 [DiffusionPipeline](/docs/diffusers/v0.23.0/en/api/pipelines/overview#diffusers.DiffusionPipeline) 
. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)
 



 In addition the pipeline inherits the following loading methods:
 


* *LoRA* 
 :
 [loaders.StableDiffusionXLLoraLoaderMixin.load\_lora\_weights()](/docs/diffusers/v0.23.0/en/api/loaders#diffusers.loaders.StableDiffusionXLLoraLoaderMixin.load_lora_weights)
* *Ckpt* 
 :
 [loaders.FromSingleFileMixin.from\_single\_file()](/docs/diffusers/v0.23.0/en/api/pipelines/stable_diffusion/text2img#diffusers.StableDiffusionPipeline.from_single_file)



 as well as the following saving methods:
 


* *LoRA* 
 :
 `loaders.StableDiffusionXLLoraLoaderMixin.save_lora_weights()`



#### 




 \_\_call\_\_




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L699)



 (
 


 prompt
 
 : typing.Union[str, typing.List[str]] = None
 




 prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 height
 
 : typing.Optional[int] = None
 




 width
 
 : typing.Optional[int] = None
 




 num\_inference\_steps
 
 : int = 50
 




 denoising\_end
 
 : typing.Optional[float] = None
 




 guidance\_scale
 
 : float = 5.0
 




 negative\_prompt
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 negative\_prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 num\_images\_per\_prompt
 
 : typing.Optional[int] = 1
 




 eta
 
 : float = 0.0
 




 generator
 
 : typing.Union[torch.\_C.Generator, typing.List[torch.\_C.Generator], NoneType] = None
 




 latents
 
 : typing.Optional[torch.FloatTensor] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 output\_type
 
 : typing.Optional[str] = 'pil'
 




 return\_dict
 
 : bool = True
 




 cross\_attention\_kwargs
 
 : typing.Union[typing.Dict[str, typing.Any], NoneType] = None
 




 guidance\_rescale
 
 : float = 0.0
 




 original\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 target\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 negative\_original\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 negative\_crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 negative\_target\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 clip\_skip
 
 : typing.Optional[int] = None
 




 callback\_on\_step\_end
 
 : typing.Union[typing.Callable[[int, int, typing.Dict], NoneType], NoneType] = None
 




 callback\_on\_step\_end\_tensor\_inputs
 
 : typing.List[str] = ['latents']
 




 \*\*kwargs
 




 )
 

 →
 



 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion_xl.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to guide the image generation. If not defined, one has to pass
 `prompt_embeds` 
.
instead.
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
* **height** 
 (
 `int` 
 ,
 *optional* 
 , defaults to self.unet.config.sample\_size \* self.vae\_scale\_factor) —
The height in pixels of the generated image. This is set to 1024 by default for the best results.
Anything below 512 pixels won’t work well for
 [stabilityai/stable-diffusion-xl-base-1.0](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0) 
 and checkpoints that are not specifically fine-tuned on low resolutions.
* **width** 
 (
 `int` 
 ,
 *optional* 
 , defaults to self.unet.config.sample\_size \* self.vae\_scale\_factor) —
The width in pixels of the generated image. This is set to 1024 by default for the best results.
Anything below 512 pixels won’t work well for
 [stabilityai/stable-diffusion-xl-base-1.0](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0) 
 and checkpoints that are not specifically fine-tuned on low resolutions.
* **num\_inference\_steps** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 50) —
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference.
* **denoising\_end** 
 (
 `float` 
 ,
 *optional* 
 ) —
When specified, determines the fraction (between 0.0 and 1.0) of the total denoising process to be
completed before it is intentionally prematurely terminated. As a result, the returned sample will
still retain a substantial amount of noise as determined by the discrete timesteps selected by the
scheduler. The denoising\_end parameter should ideally be utilized when this pipeline forms a part of a
“Mixture of Denoisers” multi-pipeline setup, as elaborated in
 [**Refining the Image
Output**](https://huggingface.co/docs/diffusers/api/pipelines/stable_diffusion/stable_diffusion_xl#refining-the-image-output)
* **guidance\_scale** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 5.0) —
Guidance scale as defined in
 [Classifier-Free Diffusion Guidance](https://arxiv.org/abs/2207.12598) 
.
 `guidance_scale` 
 is defined as
 `w` 
 of equation 2. of
 [Imagen
Paper](https://arxiv.org/pdf/2205.11487.pdf) 
. Guidance scale is enabled by setting
 `guidance_scale > 1` 
. Higher guidance scale encourages to generate images that are closely linked to the text
 `prompt` 
 ,
usually at the expense of lower image quality.
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **num\_images\_per\_prompt** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 1) —
The number of images to generate per prompt.
* **eta** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.0) —
Corresponds to parameter eta (η) in the DDIM paper:
 <https://arxiv.org/abs/2010.02502>
. Only applies to
 [schedulers.DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 , will be ignored for others.
* **generator** 
 (
 `torch.Generator` 
 or
 `List[torch.Generator]` 
 ,
 *optional* 
 ) —
One or a list of
 [torch generator(s)](https://pytorch.org/docs/stable/generated/torch.Generator.html) 
 to make generation deterministic.
* **latents** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated noisy latents, sampled from a Gaussian distribution, to be used as inputs for image
generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
tensor will ge generated by sampling using the supplied random
 `generator` 
.
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **output\_type** 
 (
 `str` 
 ,
 *optional* 
 , defaults to
 `"pil"` 
 ) —
The output format of the generate image. Choose between
 [PIL](https://pillow.readthedocs.io/en/stable/) 
 :
 `PIL.Image.Image` 
 or
 `np.array` 
.
* **return\_dict** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `True` 
 ) —
Whether or not to return a
 `~pipelines.stable_diffusion_xl.StableDiffusionXLPipelineOutput` 
 instead
of a plain tuple.
* **cross\_attention\_kwargs** 
 (
 `dict` 
 ,
 *optional* 
 ) —
A kwargs dictionary that if specified is passed along to the
 `AttentionProcessor` 
 as defined under
 `self.processor` 
 in
 [diffusers.models.attention\_processor](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/attention_processor.py) 
.
* **guidance\_rescale** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.0) —
Guidance rescale factor proposed by
 [Common Diffusion Noise Schedules and Sample Steps are
Flawed](https://arxiv.org/pdf/2305.08891.pdf) 
`guidance_scale` 
 is defined as
 `φ` 
 in equation 16. of
 [Common Diffusion Noise Schedules and Sample Steps are Flawed](https://arxiv.org/pdf/2305.08891.pdf) 
.
Guidance rescale factor should fix overexposure when using zero terminal SNR.
* **original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
If
 `original_size` 
 is not the same as
 `target_size` 
 the image will appear to be down- or upsampled.
 `original_size` 
 defaults to
 `(height, width)` 
 if not specified. Part of SDXL’s micro-conditioning as
explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
 `crops_coords_top_left` 
 can be used to generate an image that appears to be “cropped” from the position
 `crops_coords_top_left` 
 downwards. Favorable, well-centered images are usually achieved by setting
 `crops_coords_top_left` 
 to (0, 0). Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
For most cases,
 `target_size` 
 should be set to the desired height and width of the generated image. If
not specified it will default to
 `(height, width)` 
. Part of SDXL’s micro-conditioning as explained in
section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **negative\_original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a specific image resolution. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
To negatively condition the generation process based on a specific crop coordinates. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a target image resolution. It should be as same
as the
 `target_size` 
 for most cases. Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **callback\_on\_step\_end** 
 (
 `Callable` 
 ,
 *optional* 
 ) —
A function that calls at the end of each denoising steps during the inference. The function is called
with the following arguments:
 `callback_on_step_end(self: DiffusionPipeline, step: int, timestep: int, callback_kwargs: Dict)` 
.
 `callback_kwargs` 
 will include a list of all tensors as specified by
 `callback_on_step_end_tensor_inputs` 
.
* **callback\_on\_step\_end\_tensor\_inputs** 
 (
 `List` 
 ,
 *optional* 
 ) —
The list of tensor inputs for the
 `callback_on_step_end` 
 function. The tensors specified in the list
will be passed as
 `callback_kwargs` 
 argument. You will only be able to include variables listed in the
 `._callback_tensor_inputs` 
 attribute of your pipeine class.




 Returns
 




 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion_xl.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 




 export const metadata = 'undefined';
 




`~pipelines.stable_diffusion_xl.StableDiffusionXLPipelineOutput` 
 if
 `return_dict` 
 is True, otherwise a
 `tuple` 
. When returning a tuple, the first element is a list with the generated images.
 



 Function invoked when calling the pipeline for generation.
 


 Examples:
 



```
>>> import torch
>>> from diffusers import StableDiffusionXLPipeline

>>> pipe = StableDiffusionXLPipeline.from_pretrained(
...     "stabilityai/stable-diffusion-xl-base-1.0", torch_dtype=torch.float16
... )
>>> pipe = pipe.to("cuda")

>>> prompt = "a photo of an astronaut riding a horse on mars"
>>> image = pipe(prompt).images[0]
```


#### 




 disable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L635)



 (
 

 )
 




 Disables the FreeU mechanism if enabled.
 




#### 




 disable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L200)



 (
 

 )
 




 Disable sliced VAE decoding. If
 `enable_vae_slicing` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 disable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L217)



 (
 

 )
 




 Disable tiled VAE decoding. If
 `enable_vae_tiling` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 enable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L612)



 (
 


 s1
 
 : float
 




 s2
 
 : float
 




 b1
 
 : float
 




 b2
 
 : float
 



 )
 


 Parameters
 




* **s1** 
 (
 `float` 
 ) —
Scaling factor for stage 1 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **s2** 
 (
 `float` 
 ) —
Scaling factor for stage 2 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **b1** 
 (
 `float` 
 ) — Scaling factor for stage 1 to amplify the contributions of backbone features.
* **b2** 
 (
 `float` 
 ) — Scaling factor for stage 2 to amplify the contributions of backbone features.


 Enables the FreeU mechanism as in
 <https://arxiv.org/abs/2309.11497>
.
 



 The suffixes after the scaling factors represent the stages where they are being applied.
 



 Please refer to the
 [official repository](https://github.com/ChenyangSi/FreeU) 
 for combinations of the values
that are known to work well for different pipelines such as Stable Diffusion v1, v2, and Stable Diffusion XL.
 




#### 




 enable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L192)



 (
 

 )
 




 Enable sliced VAE decoding. When this option is enabled, the VAE will split the input tensor in slices to
compute decoding in several steps. This is useful to save some memory and allow larger batch sizes.
 




#### 




 enable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L208)



 (
 

 )
 




 Enable tiled VAE decoding. When this option is enabled, the VAE will split the input tensor into tiles to
compute decoding and encoding in several steps. This is useful for saving a large amount of memory and to allow
processing larger images.
 




#### 




 encode\_prompt




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L224)



 (
 


 prompt
 
 : str
 




 prompt\_2
 
 : typing.Optional[str] = None
 




 device
 
 : typing.Optional[torch.device] = None
 




 num\_images\_per\_prompt
 
 : int = 1
 




 do\_classifier\_free\_guidance
 
 : bool = True
 




 negative\_prompt
 
 : typing.Optional[str] = None
 




 negative\_prompt\_2
 
 : typing.Optional[str] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 lora\_scale
 
 : typing.Optional[float] = None
 




 clip\_skip
 
 : typing.Optional[int] = None
 



 )
 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
prompt to be encoded
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
device — (
 `torch.device` 
 ):
torch device
* **num\_images\_per\_prompt** 
 (
 `int` 
 ) —
number of images that should be generated per prompt
* **do\_classifier\_free\_guidance** 
 (
 `bool` 
 ) —
whether to use classifier free guidance or not
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **lora\_scale** 
 (
 `float` 
 ,
 *optional* 
 ) —
A lora scale that will be applied to all LoRA layers of the text encoder if LoRA layers are loaded.
* **clip\_skip** 
 (
 `int` 
 ,
 *optional* 
 ) —
Number of layers to be skipped from CLIP while computing the prompt embeddings. A value of 1 means that
the output of the pre-final layer will be used for computing the prompt embeddings.


 Encodes the prompt into text encoder hidden states.
 




#### 




 get\_guidance\_scale\_embedding




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl.py#L640)



 (
 


 w
 


 embedding\_dim
 
 = 512
 




 dtype
 
 = torch.float32
 



 )
 

 →
 



 export const metadata = 'undefined';
 

`torch.FloatTensor` 


 Parameters
 




* **timesteps** 
 (
 `torch.Tensor` 
 ) —
generate embedding vectors at these timesteps
* **embedding\_dim** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 512) —
dimension of the embeddings to generate
dtype —
data type of the generated embeddings




 Returns
 




 export const metadata = 'undefined';
 

`torch.FloatTensor` 




 export const metadata = 'undefined';
 




 Embedding vectors with shape
 `(len(timesteps), embedding_dim)` 




 See
 <https://github.com/google-research/vdm/blob/dc27b98a554f65cdc654b800da5aa1846545d41b/model_vdm.py#L298>


## StableDiffusionXLImg2ImgPipeline




### 




 class
 

 diffusers.
 

 StableDiffusionXLImg2ImgPipeline




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L106)



 (
 


 vae
 
 : AutoencoderKL
 




 text\_encoder
 
 : CLIPTextModel
 




 text\_encoder\_2
 
 : CLIPTextModelWithProjection
 




 tokenizer
 
 : CLIPTokenizer
 




 tokenizer\_2
 
 : CLIPTokenizer
 




 unet
 
 : UNet2DConditionModel
 




 scheduler
 
 : KarrasDiffusionSchedulers
 




 requires\_aesthetics\_score
 
 : bool = False
 




 force\_zeros\_for\_empty\_prompt
 
 : bool = True
 




 add\_watermarker
 
 : typing.Optional[bool] = None
 



 )
 


 Parameters
 




* **vae** 
 (
 [AutoencoderKL](/docs/diffusers/v0.23.0/en/api/models/autoencoderkl#diffusers.AutoencoderKL) 
 ) —
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.
* **text\_encoder** 
 (
 `CLIPTextModel` 
 ) —
Frozen text-encoder. Stable Diffusion XL uses the text portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel) 
 , specifically
the
 [clip-vit-large-patch14](https://huggingface.co/openai/clip-vit-large-patch14) 
 variant.
* **text\_encoder\_2** 
 (
 `CLIPTextModelWithProjection` 
 ) —
Second frozen text-encoder. Stable Diffusion XL uses the text and pool portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModelWithProjection) 
 ,
specifically the
 [laion/CLIP-ViT-bigG-14-laion2B-39B-b160k](https://huggingface.co/laion/CLIP-ViT-bigG-14-laion2B-39B-b160k) 
 variant.
* **tokenizer** 
 (
 `CLIPTokenizer` 
 ) —
Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **tokenizer\_2** 
 (
 `CLIPTokenizer` 
 ) —
Second Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **unet** 
 (
 [UNet2DConditionModel](/docs/diffusers/v0.23.0/en/api/models/unet2d-cond#diffusers.UNet2DConditionModel) 
 ) — Conditional U-Net architecture to denoise the encoded image latents.
* **scheduler** 
 (
 [SchedulerMixin](/docs/diffusers/v0.23.0/en/api/schedulers/overview#diffusers.SchedulerMixin) 
 ) —
A scheduler to be used in combination with
 `unet` 
 to denoise the encoded image latents. Can be one of
 [DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 ,
 [LMSDiscreteScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/lms_discrete#diffusers.LMSDiscreteScheduler) 
 , or
 [PNDMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/pndm#diffusers.PNDMScheduler) 
.
* **requires\_aesthetics\_score** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `"False"` 
 ) —
Whether the
 `unet` 
 requires an
 `aesthetic_score` 
 condition to be passed during inference. Also see the
config of
 `stabilityai/stable-diffusion-xl-refiner-1-0` 
.
* **force\_zeros\_for\_empty\_prompt** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `"True"` 
 ) —
Whether the negative prompt embeddings shall be forced to always be set to 0. Also see the config of
 `stabilityai/stable-diffusion-xl-base-1-0` 
.
* **add\_watermarker** 
 (
 `bool` 
 ,
 *optional* 
 ) —
Whether to use the
 [invisible\_watermark library](https://github.com/ShieldMnt/invisible-watermark/) 
 to
watermark output images. If not defined, it will default to True if the package is installed, otherwise no
watermarker will be used.


 Pipeline for text-to-image generation using Stable Diffusion XL.
 



 This model inherits from
 [DiffusionPipeline](/docs/diffusers/v0.23.0/en/api/pipelines/overview#diffusers.DiffusionPipeline) 
. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)
 



 In addition the pipeline inherits the following loading methods:
 


* *LoRA* 
 :
 [loaders.StableDiffusionXLLoraLoaderMixin.load\_lora\_weights()](/docs/diffusers/v0.23.0/en/api/loaders#diffusers.loaders.StableDiffusionXLLoraLoaderMixin.load_lora_weights)
* *Ckpt* 
 :
 [loaders.FromSingleFileMixin.from\_single\_file()](/docs/diffusers/v0.23.0/en/api/pipelines/stable_diffusion/text2img#diffusers.StableDiffusionPipeline.from_single_file)



 as well as the following saving methods:
 


* *LoRA* 
 :
 `loaders.StableDiffusionXLLoraLoaderMixin.save_lora_weights()`



#### 




 \_\_call\_\_




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L830)



 (
 


 prompt
 
 : typing.Union[str, typing.List[str]] = None
 




 prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 image
 
 : typing.Union[PIL.Image.Image, numpy.ndarray, torch.FloatTensor, typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[torch.FloatTensor]] = None
 




 strength
 
 : float = 0.3
 




 num\_inference\_steps
 
 : int = 50
 




 denoising\_start
 
 : typing.Optional[float] = None
 




 denoising\_end
 
 : typing.Optional[float] = None
 




 guidance\_scale
 
 : float = 5.0
 




 negative\_prompt
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 negative\_prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 num\_images\_per\_prompt
 
 : typing.Optional[int] = 1
 




 eta
 
 : float = 0.0
 




 generator
 
 : typing.Union[torch.\_C.Generator, typing.List[torch.\_C.Generator], NoneType] = None
 




 latents
 
 : typing.Optional[torch.FloatTensor] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 output\_type
 
 : typing.Optional[str] = 'pil'
 




 return\_dict
 
 : bool = True
 




 cross\_attention\_kwargs
 
 : typing.Union[typing.Dict[str, typing.Any], NoneType] = None
 




 guidance\_rescale
 
 : float = 0.0
 




 original\_size
 
 : typing.Tuple[int, int] = None
 




 crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 target\_size
 
 : typing.Tuple[int, int] = None
 




 negative\_original\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 negative\_crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 negative\_target\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 aesthetic\_score
 
 : float = 6.0
 




 negative\_aesthetic\_score
 
 : float = 2.5
 




 clip\_skip
 
 : typing.Optional[int] = None
 




 callback\_on\_step\_end
 
 : typing.Union[typing.Callable[[int, int, typing.Dict], NoneType], NoneType] = None
 




 callback\_on\_step\_end\_tensor\_inputs
 
 : typing.List[str] = ['latents']
 




 \*\*kwargs
 




 )
 

 →
 



 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to guide the image generation. If not defined, one has to pass
 `prompt_embeds` 
.
instead.
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
* **image** 
 (
 `torch.FloatTensor` 
 or
 `PIL.Image.Image` 
 or
 `np.ndarray` 
 or
 `List[torch.FloatTensor]` 
 or
 `List[PIL.Image.Image]` 
 or
 `List[np.ndarray]` 
 ) —
The image(s) to modify with the pipeline.
* **strength** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.3) —
Conceptually, indicates how much to transform the reference
 `image` 
. Must be between 0 and 1.
 `image` 
 will be used as a starting point, adding more noise to it the larger the
 `strength` 
. The number of
denoising steps depends on the amount of noise initially added. When
 `strength` 
 is 1, added noise will
be maximum and the denoising process will run for the full number of iterations specified in
 `num_inference_steps` 
. A value of 1, therefore, essentially ignores
 `image` 
. Note that in the case of
 `denoising_start` 
 being declared as an integer, the value of
 `strength` 
 will be ignored.
* **num\_inference\_steps** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 50) —
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference.
* **denoising\_start** 
 (
 `float` 
 ,
 *optional* 
 ) —
When specified, indicates the fraction (between 0.0 and 1.0) of the total denoising process to be
bypassed before it is initiated. Consequently, the initial part of the denoising process is skipped and
it is assumed that the passed
 `image` 
 is a partly denoised image. Note that when this is specified,
strength will be ignored. The
 `denoising_start` 
 parameter is particularly beneficial when this pipeline
is integrated into a “Mixture of Denoisers” multi-pipeline setup, as detailed in
 [**Refine Image
Quality**](https://huggingface.co/docs/diffusers/using-diffusers/sdxl#refine-image-quality)
.
* **denoising\_end** 
 (
 `float` 
 ,
 *optional* 
 ) —
When specified, determines the fraction (between 0.0 and 1.0) of the total denoising process to be
completed before it is intentionally prematurely terminated. As a result, the returned sample will
still retain a substantial amount of noise (ca. final 20% of timesteps still needed) and should be
denoised by a successor pipeline that has
 `denoising_start` 
 set to 0.8 so that it only denoises the
final 20% of the scheduler. The denoising\_end parameter should ideally be utilized when this pipeline
forms a part of a “Mixture of Denoisers” multi-pipeline setup, as elaborated in
 [**Refine Image
Quality**](https://huggingface.co/docs/diffusers/using-diffusers/sdxl#refine-image-quality)
.
* **guidance\_scale** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 7.5) —
Guidance scale as defined in
 [Classifier-Free Diffusion Guidance](https://arxiv.org/abs/2207.12598) 
.
 `guidance_scale` 
 is defined as
 `w` 
 of equation 2. of
 [Imagen
Paper](https://arxiv.org/pdf/2205.11487.pdf) 
. Guidance scale is enabled by setting
 `guidance_scale > 1` 
. Higher guidance scale encourages to generate images that are closely linked to the text
 `prompt` 
 ,
usually at the expense of lower image quality.
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **num\_images\_per\_prompt** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 1) —
The number of images to generate per prompt.
* **eta** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.0) —
Corresponds to parameter eta (η) in the DDIM paper:
 <https://arxiv.org/abs/2010.02502>
. Only applies to
 [schedulers.DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 , will be ignored for others.
* **generator** 
 (
 `torch.Generator` 
 or
 `List[torch.Generator]` 
 ,
 *optional* 
 ) —
One or a list of
 [torch generator(s)](https://pytorch.org/docs/stable/generated/torch.Generator.html) 
 to make generation deterministic.
* **latents** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated noisy latents, sampled from a Gaussian distribution, to be used as inputs for image
generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
tensor will ge generated by sampling using the supplied random
 `generator` 
.
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **output\_type** 
 (
 `str` 
 ,
 *optional* 
 , defaults to
 `"pil"` 
 ) —
The output format of the generate image. Choose between
 [PIL](https://pillow.readthedocs.io/en/stable/) 
 :
 `PIL.Image.Image` 
 or
 `np.array` 
.
* **return\_dict** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `True` 
 ) —
Whether or not to return a
 `~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 instead of a
plain tuple.
* **cross\_attention\_kwargs** 
 (
 `dict` 
 ,
 *optional* 
 ) —
A kwargs dictionary that if specified is passed along to the
 `AttentionProcessor` 
 as defined under
 `self.processor` 
 in
 [diffusers.models.attention\_processor](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/attention_processor.py) 
.
* **guidance\_rescale** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.0) —
Guidance rescale factor proposed by
 [Common Diffusion Noise Schedules and Sample Steps are
Flawed](https://arxiv.org/pdf/2305.08891.pdf) 
`guidance_scale` 
 is defined as
 `φ` 
 in equation 16. of
 [Common Diffusion Noise Schedules and Sample Steps are Flawed](https://arxiv.org/pdf/2305.08891.pdf) 
.
Guidance rescale factor should fix overexposure when using zero terminal SNR.
* **original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
If
 `original_size` 
 is not the same as
 `target_size` 
 the image will appear to be down- or upsampled.
 `original_size` 
 defaults to
 `(height, width)` 
 if not specified. Part of SDXL’s micro-conditioning as
explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
 `crops_coords_top_left` 
 can be used to generate an image that appears to be “cropped” from the position
 `crops_coords_top_left` 
 downwards. Favorable, well-centered images are usually achieved by setting
 `crops_coords_top_left` 
 to (0, 0). Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
For most cases,
 `target_size` 
 should be set to the desired height and width of the generated image. If
not specified it will default to
 `(height, width)` 
. Part of SDXL’s micro-conditioning as explained in
section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **negative\_original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a specific image resolution. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
To negatively condition the generation process based on a specific crop coordinates. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a target image resolution. It should be as same
as the
 `target_size` 
 for most cases. Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **aesthetic\_score** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 6.0) —
Used to simulate an aesthetic score of the generated image by influencing the positive text condition.
Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **negative\_aesthetic\_score** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 2.5) —
Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. Can be used to
simulate an aesthetic score of the generated image by influencing the negative text condition.
* **clip\_skip** 
 (
 `int` 
 ,
 *optional* 
 ) —
Number of layers to be skipped from CLIP while computing the prompt embeddings. A value of 1 means that
the output of the pre-final layer will be used for computing the prompt embeddings.
* **callback\_on\_step\_end** 
 (
 `Callable` 
 ,
 *optional* 
 ) —
A function that calls at the end of each denoising steps during the inference. The function is called
with the following arguments:
 `callback_on_step_end(self: DiffusionPipeline, step: int, timestep: int, callback_kwargs: Dict)` 
.
 `callback_kwargs` 
 will include a list of all tensors as specified by
 `callback_on_step_end_tensor_inputs` 
.
* **callback\_on\_step\_end\_tensor\_inputs** 
 (
 `List` 
 ,
 *optional* 
 ) —
The list of tensor inputs for the
 `callback_on_step_end` 
 function. The tensors specified in the list
will be passed as
 `callback_kwargs` 
 argument. You will only be able to include variables listed in the
 `._callback_tensor_inputs` 
 attribute of your pipeine class.




 Returns
 




 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 




 export const metadata = 'undefined';
 




`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 if
 `return_dict` 
 is True, otherwise a
`tuple. When returning a tuple, the first element is a list with the generated images.
 



 Function invoked when calling the pipeline for generation.
 


 Examples:
 



```
>>> import torch
>>> from diffusers import StableDiffusionXLImg2ImgPipeline
>>> from diffusers.utils import load_image

>>> pipe = StableDiffusionXLImg2ImgPipeline.from_pretrained(
...     "stabilityai/stable-diffusion-xl-refiner-1.0", torch_dtype=torch.float16
... )
>>> pipe = pipe.to("cuda")
>>> url = "https://huggingface.co/datasets/patrickvonplaten/images/resolve/main/aa\_xl/000000009.png"

>>> init_image = load_image(url).convert("RGB")
>>> prompt = "a photo of an astronaut riding a horse on mars"
>>> image = pipe(prompt, image=init_image).images[0]
```


#### 




 disable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L762)



 (
 

 )
 




 Disables the FreeU mechanism if enabled.
 




#### 




 disable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L213)



 (
 

 )
 




 Disable sliced VAE decoding. If
 `enable_vae_slicing` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 disable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L230)



 (
 

 )
 




 Disable tiled VAE decoding. If
 `enable_vae_tiling` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 enable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L739)



 (
 


 s1
 
 : float
 




 s2
 
 : float
 




 b1
 
 : float
 




 b2
 
 : float
 



 )
 


 Parameters
 




* **s1** 
 (
 `float` 
 ) —
Scaling factor for stage 1 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **s2** 
 (
 `float` 
 ) —
Scaling factor for stage 2 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **b1** 
 (
 `float` 
 ) — Scaling factor for stage 1 to amplify the contributions of backbone features.
* **b2** 
 (
 `float` 
 ) — Scaling factor for stage 2 to amplify the contributions of backbone features.


 Enables the FreeU mechanism as in
 <https://arxiv.org/abs/2309.11497>
.
 



 The suffixes after the scaling factors represent the stages where they are being applied.
 



 Please refer to the
 [official repository](https://github.com/ChenyangSi/FreeU) 
 for combinations of the values
that are known to work well for different pipelines such as Stable Diffusion v1, v2, and Stable Diffusion XL.
 




#### 




 enable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L205)



 (
 

 )
 




 Enable sliced VAE decoding. When this option is enabled, the VAE will split the input tensor in slices to
compute decoding in several steps. This is useful to save some memory and allow larger batch sizes.
 




#### 




 enable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L221)



 (
 

 )
 




 Enable tiled VAE decoding. When this option is enabled, the VAE will split the input tensor into tiles to
compute decoding and encoding in several steps. This is useful for saving a large amount of memory and to allow
processing larger images.
 




#### 




 encode\_prompt




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L238)



 (
 


 prompt
 
 : str
 




 prompt\_2
 
 : typing.Optional[str] = None
 




 device
 
 : typing.Optional[torch.device] = None
 




 num\_images\_per\_prompt
 
 : int = 1
 




 do\_classifier\_free\_guidance
 
 : bool = True
 




 negative\_prompt
 
 : typing.Optional[str] = None
 




 negative\_prompt\_2
 
 : typing.Optional[str] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 lora\_scale
 
 : typing.Optional[float] = None
 




 clip\_skip
 
 : typing.Optional[int] = None
 



 )
 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
prompt to be encoded
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
device — (
 `torch.device` 
 ):
torch device
* **num\_images\_per\_prompt** 
 (
 `int` 
 ) —
number of images that should be generated per prompt
* **do\_classifier\_free\_guidance** 
 (
 `bool` 
 ) —
whether to use classifier free guidance or not
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **lora\_scale** 
 (
 `float` 
 ,
 *optional* 
 ) —
A lora scale that will be applied to all LoRA layers of the text encoder if LoRA layers are loaded.
* **clip\_skip** 
 (
 `int` 
 ,
 *optional* 
 ) —
Number of layers to be skipped from CLIP while computing the prompt embeddings. A value of 1 means that
the output of the pre-final layer will be used for computing the prompt embeddings.


 Encodes the prompt into text encoder hidden states.
 




#### 




 get\_guidance\_scale\_embedding




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_img2img.py#L767)



 (
 


 w
 


 embedding\_dim
 
 = 512
 




 dtype
 
 = torch.float32
 



 )
 

 →
 



 export const metadata = 'undefined';
 

`torch.FloatTensor` 


 Parameters
 




* **timesteps** 
 (
 `torch.Tensor` 
 ) —
generate embedding vectors at these timesteps
* **embedding\_dim** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 512) —
dimension of the embeddings to generate
dtype —
data type of the generated embeddings




 Returns
 




 export const metadata = 'undefined';
 

`torch.FloatTensor` 




 export const metadata = 'undefined';
 




 Embedding vectors with shape
 `(len(timesteps), embedding_dim)` 




 See
 <https://github.com/google-research/vdm/blob/dc27b98a554f65cdc654b800da5aa1846545d41b/model_vdm.py#L298>


## StableDiffusionXLInpaintPipeline




### 




 class
 

 diffusers.
 

 StableDiffusionXLInpaintPipeline




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L251)



 (
 


 vae
 
 : AutoencoderKL
 




 text\_encoder
 
 : CLIPTextModel
 




 text\_encoder\_2
 
 : CLIPTextModelWithProjection
 




 tokenizer
 
 : CLIPTokenizer
 




 tokenizer\_2
 
 : CLIPTokenizer
 




 unet
 
 : UNet2DConditionModel
 




 scheduler
 
 : KarrasDiffusionSchedulers
 




 requires\_aesthetics\_score
 
 : bool = False
 




 force\_zeros\_for\_empty\_prompt
 
 : bool = True
 




 add\_watermarker
 
 : typing.Optional[bool] = None
 



 )
 


 Parameters
 




* **vae** 
 (
 [AutoencoderKL](/docs/diffusers/v0.23.0/en/api/models/autoencoderkl#diffusers.AutoencoderKL) 
 ) —
Variational Auto-Encoder (VAE) Model to encode and decode images to and from latent representations.
* **text\_encoder** 
 (
 `CLIPTextModel` 
 ) —
Frozen text-encoder. Stable Diffusion XL uses the text portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModel) 
 , specifically
the
 [clip-vit-large-patch14](https://huggingface.co/openai/clip-vit-large-patch14) 
 variant.
* **text\_encoder\_2** 
 (
 `CLIPTextModelWithProjection` 
 ) —
Second frozen text-encoder. Stable Diffusion XL uses the text and pool portion of
 [CLIP](https://huggingface.co/docs/transformers/model_doc/clip#transformers.CLIPTextModelWithProjection) 
 ,
specifically the
 [laion/CLIP-ViT-bigG-14-laion2B-39B-b160k](https://huggingface.co/laion/CLIP-ViT-bigG-14-laion2B-39B-b160k) 
 variant.
* **tokenizer** 
 (
 `CLIPTokenizer` 
 ) —
Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **tokenizer\_2** 
 (
 `CLIPTokenizer` 
 ) —
Second Tokenizer of class
 [CLIPTokenizer](https://huggingface.co/docs/transformers/v4.21.0/en/model_doc/clip#transformers.CLIPTokenizer) 
.
* **unet** 
 (
 [UNet2DConditionModel](/docs/diffusers/v0.23.0/en/api/models/unet2d-cond#diffusers.UNet2DConditionModel) 
 ) — Conditional U-Net architecture to denoise the encoded image latents.
* **scheduler** 
 (
 [SchedulerMixin](/docs/diffusers/v0.23.0/en/api/schedulers/overview#diffusers.SchedulerMixin) 
 ) —
A scheduler to be used in combination with
 `unet` 
 to denoise the encoded image latents. Can be one of
 [DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 ,
 [LMSDiscreteScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/lms_discrete#diffusers.LMSDiscreteScheduler) 
 , or
 [PNDMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/pndm#diffusers.PNDMScheduler) 
.
* **requires\_aesthetics\_score** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `"False"` 
 ) —
Whether the
 `unet` 
 requires a aesthetic\_score condition to be passed during inference. Also see the config
of
 `stabilityai/stable-diffusion-xl-refiner-1-0` 
.
* **force\_zeros\_for\_empty\_prompt** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `"True"` 
 ) —
Whether the negative prompt embeddings shall be forced to always be set to 0. Also see the config of
 `stabilityai/stable-diffusion-xl-base-1-0` 
.
* **add\_watermarker** 
 (
 `bool` 
 ,
 *optional* 
 ) —
Whether to use the
 [invisible\_watermark library](https://github.com/ShieldMnt/invisible-watermark/) 
 to
watermark output images. If not defined, it will default to True if the package is installed, otherwise no
watermarker will be used.


 Pipeline for text-to-image generation using Stable Diffusion XL.
 



 This model inherits from
 [DiffusionPipeline](/docs/diffusers/v0.23.0/en/api/pipelines/overview#diffusers.DiffusionPipeline) 
. Check the superclass documentation for the generic methods the
library implements for all the pipelines (such as downloading or saving, running on a particular device, etc.)
 



 In addition the pipeline inherits the following loading methods:
 


* *LoRA* 
 :
 [loaders.StableDiffusionXLLoraLoaderMixin.load\_lora\_weights()](/docs/diffusers/v0.23.0/en/api/loaders#diffusers.loaders.StableDiffusionXLLoraLoaderMixin.load_lora_weights)
* *Ckpt* 
 :
 [loaders.FromSingleFileMixin.from\_single\_file()](/docs/diffusers/v0.23.0/en/api/pipelines/stable_diffusion/text2img#diffusers.StableDiffusionPipeline.from_single_file)



 as well as the following saving methods:
 


* *LoRA* 
 :
 `loaders.StableDiffusionXLLoraLoaderMixin.save_lora_weights()`



#### 




 \_\_call\_\_




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L1049)



 (
 


 prompt
 
 : typing.Union[str, typing.List[str]] = None
 




 prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 image
 
 : typing.Union[PIL.Image.Image, numpy.ndarray, torch.FloatTensor, typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[torch.FloatTensor]] = None
 




 mask\_image
 
 : typing.Union[PIL.Image.Image, numpy.ndarray, torch.FloatTensor, typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[torch.FloatTensor]] = None
 




 masked\_image\_latents
 
 : FloatTensor = None
 




 height
 
 : typing.Optional[int] = None
 




 width
 
 : typing.Optional[int] = None
 




 strength
 
 : float = 0.9999
 




 num\_inference\_steps
 
 : int = 50
 




 denoising\_start
 
 : typing.Optional[float] = None
 




 denoising\_end
 
 : typing.Optional[float] = None
 




 guidance\_scale
 
 : float = 7.5
 




 negative\_prompt
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 negative\_prompt\_2
 
 : typing.Union[str, typing.List[str], NoneType] = None
 




 num\_images\_per\_prompt
 
 : typing.Optional[int] = 1
 




 eta
 
 : float = 0.0
 




 generator
 
 : typing.Union[torch.\_C.Generator, typing.List[torch.\_C.Generator], NoneType] = None
 




 latents
 
 : typing.Optional[torch.FloatTensor] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 output\_type
 
 : typing.Optional[str] = 'pil'
 




 return\_dict
 
 : bool = True
 




 cross\_attention\_kwargs
 
 : typing.Union[typing.Dict[str, typing.Any], NoneType] = None
 




 guidance\_rescale
 
 : float = 0.0
 




 original\_size
 
 : typing.Tuple[int, int] = None
 




 crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 target\_size
 
 : typing.Tuple[int, int] = None
 




 negative\_original\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 negative\_crops\_coords\_top\_left
 
 : typing.Tuple[int, int] = (0, 0)
 




 negative\_target\_size
 
 : typing.Union[typing.Tuple[int, int], NoneType] = None
 




 aesthetic\_score
 
 : float = 6.0
 




 negative\_aesthetic\_score
 
 : float = 2.5
 




 clip\_skip
 
 : typing.Optional[int] = None
 




 callback\_on\_step\_end
 
 : typing.Union[typing.Callable[[int, int, typing.Dict], NoneType], NoneType] = None
 




 callback\_on\_step\_end\_tensor\_inputs
 
 : typing.List[str] = ['latents']
 




 \*\*kwargs
 




 )
 

 →
 



 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to guide the image generation. If not defined, one has to pass
 `prompt_embeds` 
.
instead.
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
* **image** 
 (
 `PIL.Image.Image` 
 ) —
 `Image` 
 , or tensor representing an image batch which will be inpainted,
 *i.e.* 
 parts of the image will
be masked out with
 `mask_image` 
 and repainted according to
 `prompt` 
.
* **mask\_image** 
 (
 `PIL.Image.Image` 
 ) —
 `Image` 
 , or tensor representing an image batch, to mask
 `image` 
. White pixels in the mask will be
repainted, while black pixels will be preserved. If
 `mask_image` 
 is a PIL image, it will be converted
to a single channel (luminance) before use. If it’s a tensor, it should contain one color channel (L)
instead of 3, so the expected shape would be
 `(B, H, W, 1)` 
.
* **height** 
 (
 `int` 
 ,
 *optional* 
 , defaults to self.unet.config.sample\_size \* self.vae\_scale\_factor) —
The height in pixels of the generated image. This is set to 1024 by default for the best results.
Anything below 512 pixels won’t work well for
 [stabilityai/stable-diffusion-xl-base-1.0](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0) 
 and checkpoints that are not specifically fine-tuned on low resolutions.
* **width** 
 (
 `int` 
 ,
 *optional* 
 , defaults to self.unet.config.sample\_size \* self.vae\_scale\_factor) —
The width in pixels of the generated image. This is set to 1024 by default for the best results.
Anything below 512 pixels won’t work well for
 [stabilityai/stable-diffusion-xl-base-1.0](https://huggingface.co/stabilityai/stable-diffusion-xl-base-1.0) 
 and checkpoints that are not specifically fine-tuned on low resolutions.
* **strength** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.9999) —
Conceptually, indicates how much to transform the masked portion of the reference
 `image` 
. Must be
between 0 and 1.
 `image` 
 will be used as a starting point, adding more noise to it the larger the
 `strength` 
. The number of denoising steps depends on the amount of noise initially added. When
 `strength` 
 is 1, added noise will be maximum and the denoising process will run for the full number of
iterations specified in
 `num_inference_steps` 
. A value of 1, therefore, essentially ignores the masked
portion of the reference
 `image` 
. Note that in the case of
 `denoising_start` 
 being declared as an
integer, the value of
 `strength` 
 will be ignored.
* **num\_inference\_steps** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 50) —
The number of denoising steps. More denoising steps usually lead to a higher quality image at the
expense of slower inference.
* **denoising\_start** 
 (
 `float` 
 ,
 *optional* 
 ) —
When specified, indicates the fraction (between 0.0 and 1.0) of the total denoising process to be
bypassed before it is initiated. Consequently, the initial part of the denoising process is skipped and
it is assumed that the passed
 `image` 
 is a partly denoised image. Note that when this is specified,
strength will be ignored. The
 `denoising_start` 
 parameter is particularly beneficial when this pipeline
is integrated into a “Mixture of Denoisers” multi-pipeline setup, as detailed in
 [**Refining the Image
Output**](https://huggingface.co/docs/diffusers/api/pipelines/stable_diffusion/stable_diffusion_xl#refining-the-image-output)
.
* **denoising\_end** 
 (
 `float` 
 ,
 *optional* 
 ) —
When specified, determines the fraction (between 0.0 and 1.0) of the total denoising process to be
completed before it is intentionally prematurely terminated. As a result, the returned sample will
still retain a substantial amount of noise (ca. final 20% of timesteps still needed) and should be
denoised by a successor pipeline that has
 `denoising_start` 
 set to 0.8 so that it only denoises the
final 20% of the scheduler. The denoising\_end parameter should ideally be utilized when this pipeline
forms a part of a “Mixture of Denoisers” multi-pipeline setup, as elaborated in
 [**Refining the Image
Output**](https://huggingface.co/docs/diffusers/api/pipelines/stable_diffusion/stable_diffusion_xl#refining-the-image-output)
.
* **guidance\_scale** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 7.5) —
Guidance scale as defined in
 [Classifier-Free Diffusion Guidance](https://arxiv.org/abs/2207.12598) 
.
 `guidance_scale` 
 is defined as
 `w` 
 of equation 2. of
 [Imagen
Paper](https://arxiv.org/pdf/2205.11487.pdf) 
. Guidance scale is enabled by setting
 `guidance_scale > 1` 
. Higher guidance scale encourages to generate images that are closely linked to the text
 `prompt` 
 ,
usually at the expense of lower image quality.
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **num\_images\_per\_prompt** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 1) —
The number of images to generate per prompt.
* **eta** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 0.0) —
Corresponds to parameter eta (η) in the DDIM paper:
 <https://arxiv.org/abs/2010.02502>
. Only applies to
 [schedulers.DDIMScheduler](/docs/diffusers/v0.23.0/en/api/schedulers/ddim#diffusers.DDIMScheduler) 
 , will be ignored for others.
* **generator** 
 (
 `torch.Generator` 
 ,
 *optional* 
 ) —
One or a list of
 [torch generator(s)](https://pytorch.org/docs/stable/generated/torch.Generator.html) 
 to make generation deterministic.
* **latents** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated noisy latents, sampled from a Gaussian distribution, to be used as inputs for image
generation. Can be used to tweak the same generation with different prompts. If not provided, a latents
tensor will ge generated by sampling using the supplied random
 `generator` 
.
* **output\_type** 
 (
 `str` 
 ,
 *optional* 
 , defaults to
 `"pil"` 
 ) —
The output format of the generate image. Choose between
 [PIL](https://pillow.readthedocs.io/en/stable/) 
 :
 `PIL.Image.Image` 
 or
 `np.array` 
.
* **return\_dict** 
 (
 `bool` 
 ,
 *optional* 
 , defaults to
 `True` 
 ) —
Whether or not to return a
 [StableDiffusionPipelineOutput](/docs/diffusers/v0.23.0/en/api/pipelines/stable_diffusion/image_variation#diffusers.pipelines.stable_diffusion.StableDiffusionPipelineOutput) 
 instead of a
plain tuple.
* **cross\_attention\_kwargs** 
 (
 `dict` 
 ,
 *optional* 
 ) —
A kwargs dictionary that if specified is passed along to the
 `AttentionProcessor` 
 as defined under
 `self.processor` 
 in
 [diffusers.models.attention\_processor](https://github.com/huggingface/diffusers/blob/main/src/diffusers/models/attention_processor.py) 
.
* **original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
If
 `original_size` 
 is not the same as
 `target_size` 
 the image will appear to be down- or upsampled.
 `original_size` 
 defaults to
 `(height, width)` 
 if not specified. Part of SDXL’s micro-conditioning as
explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
 `crops_coords_top_left` 
 can be used to generate an image that appears to be “cropped” from the position
 `crops_coords_top_left` 
 downwards. Favorable, well-centered images are usually achieved by setting
 `crops_coords_top_left` 
 to (0, 0). Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
For most cases,
 `target_size` 
 should be set to the desired height and width of the generated image. If
not specified it will default to
 `(height, width)` 
. Part of SDXL’s micro-conditioning as explained in
section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **negative\_original\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a specific image resolution. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_crops\_coords\_top\_left** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (0, 0)) —
To negatively condition the generation process based on a specific crop coordinates. Part of SDXL’s
micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **negative\_target\_size** 
 (
 `Tuple[int]` 
 ,
 *optional* 
 , defaults to (1024, 1024)) —
To negatively condition the generation process based on a target image resolution. It should be as same
as the
 `target_size` 
 for most cases. Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. For more
information, refer to this issue thread:
 <https://github.com/huggingface/diffusers/issues/4208>
.
* **aesthetic\_score** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 6.0) —
Used to simulate an aesthetic score of the generated image by influencing the positive text condition.
Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
.
* **negative\_aesthetic\_score** 
 (
 `float` 
 ,
 *optional* 
 , defaults to 2.5) —
Part of SDXL’s micro-conditioning as explained in section 2.2 of
 <https://huggingface.co/papers/2307.01952>
. Can be used to
simulate an aesthetic score of the generated image by influencing the negative text condition.
* **clip\_skip** 
 (
 `int` 
 ,
 *optional* 
 ) —
Number of layers to be skipped from CLIP while computing the prompt embeddings. A value of 1 means that
the output of the pre-final layer will be used for computing the prompt embeddings.
* **callback\_on\_step\_end** 
 (
 `Callable` 
 ,
 *optional* 
 ) —
A function that calls at the end of each denoising steps during the inference. The function is called
with the following arguments:
 `callback_on_step_end(self: DiffusionPipeline, step: int, timestep: int, callback_kwargs: Dict)` 
.
 `callback_kwargs` 
 will include a list of all tensors as specified by
 `callback_on_step_end_tensor_inputs` 
.
* **callback\_on\_step\_end\_tensor\_inputs** 
 (
 `List` 
 ,
 *optional* 
 ) —
The list of tensor inputs for the
 `callback_on_step_end` 
 function. The tensors specified in the list
will be passed as
 `callback_kwargs` 
 argument. You will only be able to include variables listed in the
 `._callback_tensor_inputs` 
 attribute of your pipeine class.




 Returns
 




 export const metadata = 'undefined';
 

`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 or
 `tuple` 




 export const metadata = 'undefined';
 




`~pipelines.stable_diffusion.StableDiffusionXLPipelineOutput` 
 if
 `return_dict` 
 is True, otherwise a
 `tuple.` 
 tuple. When returning a tuple, the first element is a list with the generated images.
 



 Function invoked when calling the pipeline for generation.
 


 Examples:
 



```
>>> import torch
>>> from diffusers import StableDiffusionXLInpaintPipeline
>>> from diffusers.utils import load_image

>>> pipe = StableDiffusionXLInpaintPipeline.from_pretrained(
...     "stabilityai/stable-diffusion-xl-base-1.0",
...     torch_dtype=torch.float16,
...     variant="fp16",
...     use_safetensors=True,
... )
>>> pipe.to("cuda")

>>> img_url = "https://raw.githubusercontent.com/CompVis/latent-diffusion/main/data/inpainting\_examples/overture-creations-5sI6fQgYIuo.png"
>>> mask_url = "https://raw.githubusercontent.com/CompVis/latent-diffusion/main/data/inpainting\_examples/overture-creations-5sI6fQgYIuo\_mask.png"

>>> init_image = load_image(img_url).convert("RGB")
>>> mask_image = load_image(mask_url).convert("RGB")

>>> prompt = "A majestic tiger sitting on a bench"
>>> image = pipe(
...     prompt=prompt, image=init_image, mask_image=mask_image, num_inference_steps=50, strength=0.80
... ).images[0]
```


#### 




 disable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L981)



 (
 

 )
 




 Disables the FreeU mechanism if enabled.
 




#### 




 disable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L364)



 (
 

 )
 




 Disable sliced VAE decoding. If
 `enable_vae_slicing` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 disable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L381)



 (
 

 )
 




 Disable tiled VAE decoding. If
 `enable_vae_tiling` 
 was previously enabled, this method will go back to
computing decoding in one step.
 




#### 




 enable\_freeu




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L958)



 (
 


 s1
 
 : float
 




 s2
 
 : float
 




 b1
 
 : float
 




 b2
 
 : float
 



 )
 


 Parameters
 




* **s1** 
 (
 `float` 
 ) —
Scaling factor for stage 1 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **s2** 
 (
 `float` 
 ) —
Scaling factor for stage 2 to attenuate the contributions of the skip features. This is done to
mitigate “oversmoothing effect” in the enhanced denoising process.
* **b1** 
 (
 `float` 
 ) — Scaling factor for stage 1 to amplify the contributions of backbone features.
* **b2** 
 (
 `float` 
 ) — Scaling factor for stage 2 to amplify the contributions of backbone features.


 Enables the FreeU mechanism as in
 <https://arxiv.org/abs/2309.11497>
.
 



 The suffixes after the scaling factors represent the stages where they are being applied.
 



 Please refer to the
 [official repository](https://github.com/ChenyangSi/FreeU) 
 for combinations of the values
that are known to work well for different pipelines such as Stable Diffusion v1, v2, and Stable Diffusion XL.
 




#### 




 enable\_vae\_slicing




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L356)



 (
 

 )
 




 Enable sliced VAE decoding. When this option is enabled, the VAE will split the input tensor in slices to
compute decoding in several steps. This is useful to save some memory and allow larger batch sizes.
 




#### 




 enable\_vae\_tiling




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L372)



 (
 

 )
 




 Enable tiled VAE decoding. When this option is enabled, the VAE will split the input tensor into tiles to
compute decoding and encoding in several steps. This is useful for saving a large amount of memory and to allow
processing larger images.
 




#### 




 encode\_prompt




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L389)



 (
 


 prompt
 
 : str
 




 prompt\_2
 
 : typing.Optional[str] = None
 




 device
 
 : typing.Optional[torch.device] = None
 




 num\_images\_per\_prompt
 
 : int = 1
 




 do\_classifier\_free\_guidance
 
 : bool = True
 




 negative\_prompt
 
 : typing.Optional[str] = None
 




 negative\_prompt\_2
 
 : typing.Optional[str] = None
 




 prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 negative\_pooled\_prompt\_embeds
 
 : typing.Optional[torch.FloatTensor] = None
 




 lora\_scale
 
 : typing.Optional[float] = None
 




 clip\_skip
 
 : typing.Optional[int] = None
 



 )
 


 Parameters
 




* **prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
prompt to be encoded
* **prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts to be sent to the
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `prompt` 
 is
used in both text-encoders
device — (
 `torch.device` 
 ):
torch device
* **num\_images\_per\_prompt** 
 (
 `int` 
 ) —
number of images that should be generated per prompt
* **do\_classifier\_free\_guidance** 
 (
 `bool` 
 ) —
whether to use classifier free guidance or not
* **negative\_prompt** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation. If not defined, one has to pass
 `negative_prompt_embeds` 
 instead. Ignored when not using guidance (i.e., ignored if
 `guidance_scale` 
 is
less than
 `1` 
 ).
* **negative\_prompt\_2** 
 (
 `str` 
 or
 `List[str]` 
 ,
 *optional* 
 ) —
The prompt or prompts not to guide the image generation to be sent to
 `tokenizer_2` 
 and
 `text_encoder_2` 
. If not defined,
 `negative_prompt` 
 is used in both text-encoders
* **prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting. If not
provided, text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input
argument.
* **pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt weighting.
If not provided, pooled text embeddings will be generated from
 `prompt` 
 input argument.
* **negative\_pooled\_prompt\_embeds** 
 (
 `torch.FloatTensor` 
 ,
 *optional* 
 ) —
Pre-generated negative pooled text embeddings. Can be used to easily tweak text inputs,
 *e.g.* 
 prompt
weighting. If not provided, pooled negative\_prompt\_embeds will be generated from
 `negative_prompt` 
 input argument.
* **lora\_scale** 
 (
 `float` 
 ,
 *optional* 
 ) —
A lora scale that will be applied to all LoRA layers of the text encoder if LoRA layers are loaded.
* **clip\_skip** 
 (
 `int` 
 ,
 *optional* 
 ) —
Number of layers to be skipped from CLIP while computing the prompt embeddings. A value of 1 means that
the output of the pre-final layer will be used for computing the prompt embeddings.


 Encodes the prompt into text encoder hidden states.
 




#### 




 get\_guidance\_scale\_embedding




[<
 

 source
 

 >](https://github.com/huggingface/diffusers/blob/v0.23.0/src/diffusers/pipelines/stable_diffusion_xl/pipeline_stable_diffusion_xl_inpaint.py#L986)



 (
 


 w
 


 embedding\_dim
 
 = 512
 




 dtype
 
 = torch.float32
 



 )
 

 →
 



 export const metadata = 'undefined';
 

`torch.FloatTensor` 


 Parameters
 




* **timesteps** 
 (
 `torch.Tensor` 
 ) —
generate embedding vectors at these timesteps
* **embedding\_dim** 
 (
 `int` 
 ,
 *optional* 
 , defaults to 512) —
dimension of the embeddings to generate
dtype —
data type of the generated embeddings




 Returns
 




 export const metadata = 'undefined';
 

`torch.FloatTensor` 




 export const metadata = 'undefined';
 




 Embedding vectors with shape
 `(len(timesteps), embedding_dim)` 




 See
 <https://github.com/google-research/vdm/blob/dc27b98a554f65cdc654b800da5aa1846545d41b/model_vdm.py#L298>