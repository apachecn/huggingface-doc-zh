# 特征提取器的实用程序

> 译者：[片刻小哥哥](https://github.com/jiangzhonglian)
>
> 项目地址：<https://huggingface.apachecn.org/docs/transformers/internal/audio_utils>
>
> 原始地址：<https://huggingface.co/docs/transformers/internal/audio_utils>


本页列出了音频可以使用的所有实用功能
 `特征提取器`
 为了使用常见算法从原始音频计算特殊特征，例如
 *短时傅立叶变换*
 或者
 *对数梅尔谱图*
 。


其中大多数仅在您正在学习库中音频处理器的代码时才有用。


## 音频转换




#### 


Transformers.audio\_utils.hertz\_to\_mel


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L25)


（


 频率
 
 : 打字.Union[float, numpy.ndarray]


梅尔\_规模
 
 :str = 'htk'


）
 

 →


导出常量元数据='未定义';
 

`浮动`
 或者
 `np.ndarray`


 参数


* **频率**
 （
 `浮动`
 或者
 `np.ndarray`
 )—
频率或多个频率，以赫兹 (Hz) 为单位。
* **梅尔\_规模**
 （
 `str`
 ,
 *选修的*
 ，默认为
 `“htk”`
 )—
要使用的梅尔频率量表，
 `“htk”`
 ,
 `“卡尔迪”`
 或者
 `“斯莱尼”`
 。


退货


导出常量元数据='未定义';
 

`浮动`
 或者
 `np.ndarray`


导出常量元数据='未定义';


梅尔标度上的频率。


将频率从赫兹转换为梅尔。




#### 


Transformers.audio\_utils.mel\_to\_hertz


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L61)


（


 梅尔斯
 
 : 打字.Union[float, numpy.ndarray]


梅尔\_规模
 
 :str = 'htk'


）
 

 →


导出常量元数据='未定义';
 

`浮动`
 或者
 `np.ndarray`


 参数


* **梅尔斯**
 （
 `浮动`
 或者
 `np.ndarray`
 )—
频率或多个频率，以梅尔为单位。
* **梅尔\_规模**
 （
 `str`
 ,
 *选修的*
 ,
 `“htk”`
 )—
要使用的梅尔频率量表，
 `“htk”`
 ,
 `“卡尔迪”`
 或者
 `“斯莱尼”`
 。


退货


导出常量元数据='未定义';
 

`浮动`
 或者
 `np.ndarray`


导出常量元数据='未定义';


频率以赫兹为单位。


将频率从梅尔转换为赫兹。




#### 


Transformers.audio\_utils.mel\_filter\_bank


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L119)


（


 频率箱数
 
 ：整数


过滤器数量
 
 ：整数


最小频率
 
 ： 漂浮


最大频率
 
 ： 漂浮


采样率
 
 ：整数


规范
 
 : 打字.可选[str] =无


梅尔\_规模
 
 :str = 'htk'


三角化\_in\_mel\_space
 
 ：布尔=假


）
 

 →


导出常量元数据='未定义';
 

`np.ndarray`
 形状（
 `num_Frequency_bins`
 ,
 `num_mel_filters`
 ）


参数


* **数量\_频率\_bins**
 （
 `int`
 )—
用于计算频谱图的频率数（应与
 `stft`
 ）。
* **num\_mel\_filters**
 （
 `int`
 )—
要生成的梅尔过滤器的数量。
* **最小\_频率**
 （
 `浮动`
 )—
感兴趣的最低频率（以 Hz 为单位）。
* **最大频率**
 （
 `浮动`
 )—
感兴趣的最高频率（以 Hz 为单位）。这不应超过
 `采样率/2`
 。
* **采样率**
 （
 `int`
 )—
音频波形的采样率。
* **标准**
 （
 `str`
 ,
 *选修的*
 )—
如果
 `“斯莱尼”`
 ，将三角形梅尔权重除以梅尔带的宽度（面积归一化）。
* **梅尔\_规模**
 （
 `str`
 ,
 *选修的*
 ，默认为
 `“htk”`
 )—
要使用的梅尔频率量表，
 `“htk”`
 ,
 `“卡尔迪”`
 或者
 `“斯莱尼”`
 。
* **将\_in\_mel\_space 三角化**
 （
 `布尔`
 ,
 *选修的*
 ，默认为
 ‘假’
 )—
如果启用此选项，则三角滤波器将应用于梅尔空间而不是频率空间。这
应设置为
 `真实`
 为了得到相同的结果
 `火炬音频`
 计算梅尔滤波器时。


退货


导出常量元数据='未定义';
 

`np.ndarray`
 形状（
 `num_Frequency_bins`
 ,
 `num_mel_filters`
 ）


导出常量元数据='未定义';


三角滤波器组矩阵。这是一个
从声谱图到梅尔声谱图的投影矩阵。


创建用于获取梅尔频谱图的频率仓转换矩阵。这被称为
 *梅尔滤波器组*
 ， 和
存在多种实现方式，其不同之处在于过滤器的数量、过滤器的形状、过滤器的方式
间隔、滤波器的带宽以及频谱扭曲的方式。这些的目标
特征是近似人类对音调相对于频率变化的非线性感知。


文献中介绍了不同组的梅尔过滤器。支持以下变体：


* MFCC FB-20：由 Davis 和 Mermelstein 于 1980 年推出，假设采样频率为 10 kHz，语音
带宽为
 `[0, 4600]`
 赫兹。
* MFCC FB-24 HTK：来自 Cambridge HMM Toolkit (HTK) (1995)，使用包含 24 个滤波器的滤波器组进行语音
带宽为
 `[0, 8000]`
 赫兹。假设采样率 ≥ 16 kHz。
* MFCC FB-40：来自 Slaney 于 1998 年编写的 Auditory Toolbox for MATLAB，假设采样率为 16 kHz，
语音带宽
 `[133, 6854]`
 赫兹。该版本还包括面积标准化。
* Sk​​owronski 和 Harris (2004) 的 HFCC-E FB-29（人为因素倒谱系数），假设采样率为
12.5 kHz 和语音带宽
 `[0, 6250]`
 赫兹。


此代码改编自
 *火炬音频*
 和
 *书库*
 。注意torchaudio的默认参数
 `melscale_fbanks`
 实施
 `“htk”`
 librosa 使用过滤器
 `“斯莱尼”`
 执行。




#### 


Transformers.audio\_utils.optimal\_fft\_length


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L207)


（


 窗口\_长度
 
 ：整数


）


查找给定的最佳 FFT 输入大小
 `窗口长度`
 。该函数需要给定的窗口长度，如果没有
已经是 2 的幂，将其四舍五入到下一个或 2 的幂。


当输入的长度是 2 的幂时，FFT 算法工作得最快，该长度可能大于大小
窗口或分析框架的。例如，如果窗口为 400 个样本，则使用 512 个样本的 FFT 输入大小
比 400 个样本的 FFT 大小更优化。使用较大的 FFT 大小不会影响检测到的频率，
它只是提供了更高的频率分辨率（即频率区间更小）。




#### 


Transformers.audio\_utils.window\_function


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L220)


（


 窗口\_长度
 
 ：整数


姓
 
 : str = '汉恩'


周期性的
 
 ：布尔=真


帧\_长度
 
 : 打字.Optional[int] = None


中心
 
 ：布尔=真


）


 参数


* **窗口\_长度**
 （
 `int`
 )—
样本中窗口的长度。
* **姓名**
 （
 `str`
 ,
 *选修的*
 ，默认为
 `“汉恩”`
 )—
窗口函数的名称。
* **定期**
 （
 `布尔`
 ,
 *选修的*
 ，默认为
 '真实'
 )—
窗口是周期性的还是对称的。
* **帧\_长度**
 （
 `int`
 ,
 *选修的*
 )—
样本中分析帧的长度。提供一个值
 `帧长度`
 如果窗户较小
比帧长度，因此它将被零填充。
* **中心**
 （
 `布尔`
 ,
 *选修的*
 ，默认为
 '真实'
 )—
是否将窗口置于 FFT 缓冲区的中心。仅在以下情况下使用
 `帧长度`
 提供。


 返回包含指定窗口的数组。该窗口旨在与
 `stft`
 。


支持以下窗口类型：


* `“棚车”`
 : 一个矩形窗口
* `“汉明”`
 ：汉明窗
* `“汉恩”`
 ：汉恩窗
* `“波维”`
 ：波维窗口




#### 


Transformers.audio\_utils.spectrogram


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L284)


（


 波形
 
 ：ndarray


窗户
 
 ：ndarray


帧\_长度
 
 ：整数


跳\_长度
 
 ：整数


fft\_length
 
 : 打字.Optional[int] = None


力量
 
 : 打字.可选[浮点] = 1.0


中心
 
 ：布尔=真


垫\_模式
 
 : str = '反映'


片面
 
 ：布尔=真


预加重
 
 : 打字.可选[浮点] = 无


梅尔过滤器
 
 ：打字。可选[numpy.ndarray] =无


梅尔\_地板
 
 : 浮点数 = 1e-10


日志\_mel
 
 : 打字.可选[str] =无


参考
 
 ：浮动= 1.0


最小值\_值
 
 : 浮点数 = 1e-10


数据库\_范围
 
 : 打字.可选[浮点] = 无


删除\_dc\_offset
 
 : 打字.Optional[bool] = None


数据类型
 
 : dtype = <类'numpy.float32'>


）


 参数


* **波形**
 （
 `np.ndarray`
 形状的
 `（长度，）`
 )—
输入波形。这必须是单个实值单声道波形。
* **窗户**
 （
 `np.ndarray`
 形状的
 `（帧长度，）`
 )—
要应用的窗口函数，包括必要时的零填充。实际窗口长度可能是
比。。。短
 `帧长度`
 ，但我们假设数组已经用零填充。
* **帧\_长度**
 （
 `int`
 )—
样本中分析帧的长度。对于 librosa，这总是等于
 `fft_length`
 但我们也
允许更小的尺寸。
* **跳跃\_长度**
 （
 `int`
 )—
样本中连续分析帧之间的步幅。
* **fft\_length**
 （
 `int`
 ,
 *选修的*
 )—
样本中 FFT 缓冲区的大小。这决定了频谱图将具有多少个频率仓。
为了获得最佳速度，这应该是 2 的幂。如果
 `无`
 ，使用
 `帧长度`
 。
* **力量**
 （
 `浮动`
 ,
 *选修的*
 ，默认为 1.0) —
如果为 1.0，则返回幅度频谱图。如果为 2.0，则返回功率谱图。如果
 `无`
 ，返回
复数。
* **中心**
 （
 `布尔`
 ,
 *选修的*
 ，默认为
 '真实'
 )—
是否填充波形以便帧
 `t`
 以时间为中心
 `t * hop_length`
 。如果
 ‘假’
 ， 框架
 `t`
 将在某个时间开始
 `t * hop_length`
 。
* **垫\_模式**
 （
 `str`
 ,
 *选修的*
 ，默认为
 `“反映”`
 )—
填充模式时使用
 `中心`
 是
 '真实'
 。可能的值为：
 `“常数”`
 （用零填充），
 `“边缘”`
 （用边缘值填充），
 `“反映”`
 （具有镜像值的焊盘）。
* **片面**
 （
 `布尔`
 ,
 *选修的*
 ，默认为
 '真实'
 )—
如果为 True，则仅计算正频率并返回包含
 `fft_length //2 + 1`
 频率仓。如果为 False，还计算负频率并返回
 `fft_length`
 频率仓。
* **预加重**
 （
 `浮动`
 ,
 *选修的*
 )—
在 DFT 之前应用预加重的低通滤波器的系数。
* **梅尔\_过滤器**
 （
 `np.ndarray`
 形状的
 `(num_freq_bins, num_mel_filters)`
 ,
 *选修的*
 )—
梅尔滤波器组。如果提供，则应用此滤波器组来创建梅尔频谱图。
* **梅尔\_地板**
 （
 `浮动`
 ,
 *选修的*
 ，默认为 1e-10) —
梅尔频率库的最小值。
* **日志\_mel**
 （
 `str`
 ,
 *选修的*
 )—
如何将频谱图转换为对数刻度。可能的选项有：
 `无`
 （不转换），
 `“日志”`
 （拿
自然对数）
 `“log10”`
 （取以 10 为底的对数），
 `“分贝”`
 （转换为分贝）。只能是
使用时
 `权力`
 不是
 `无`
 。
* **参考**
 （
 `浮动`
 ,
 *选修的*
 ，默认为 1.0) —
设置对应于 0 dB 的输入频谱图值。例如，使用
 `np.max(频谱图)`
 设置
最大声部分为 0 dB。必须大于零。
* **最小值\_值**
 （
 `浮动`
 ,
 *选修的*
 ，默认为
 `1e-10`
 )—
在转换为分贝之前，频谱图将被剪切到该最小值，以避免
 `日志(0)`
 。对于功率谱图，默认为
 `1e-10`
 对应于最小值 -100 dB。为
幅度谱图，值
 `1e-5`
 对应于-100 dB。必须大于零。
* **db\_range**
 （
 `浮动`
 ,
 *选修的*
 )—
设置最大动态范围（以分贝为单位）。例如，如果
 `db_range = 80`
 ，之间的差异
峰值和最小值绝不会超过80 dB。必须大于零。
* **删除\_dc\_offset**
 （
 `布尔`
 ,
 *选修的*
 )—
从每帧的波形中减去平均值，在预加重之前应用。这应该设置为
 `真实`
 在
为了得到相同的结果
 `torchaudio.compliance.kaldi.fbank`
 计算梅尔滤波器时。
* **数据类型**
 （
 `np.dtype`
 ,
 *选修的*
 ，默认为
 `np.float32`
 )—
谱图张量的数据类型。如果
 `权力`
 为 None，则忽略此参数，并且 dtype 将为
 `np.complex64`
 。


 使用短时傅里叶变换计算一个波形的频谱图。


该函数可以创建以下类型的频谱图：


* 幅度谱图（
 `功率= 1.0`
 ）
* 功率谱图（
 `功率= 2.0`
 ）
* 复值频谱图（
 `权力=无`
 ）
*记录频谱图（使用
 `log_mel`
 争论）
* 梅尔谱图（提供
 `mel_filters`
 ）
* log-mel 频谱图（提供
 `mel_filters`
 和
 `log_mel`
 ）


这是如何运作的：


1. 输入波形被分割成不同大小的帧
 `帧长度`
 部分重叠“frame\_length”
* hop\_length` 样本。
2、每一帧与窗口相乘，放入一个size的缓冲区中
 `fft_length`
 。
3. 对每个窗口帧进行 DFT。
4. 结果被叠加到频谱图中。


我们区分以下样本数据“块”，每个块可能具有不同的长度：


* 分析框架。这是输入波形被分割成的时间片的大小。
* 窗户。每个分析帧都乘以窗口以避免频谱泄漏。
* FFT 输入缓冲器。它的长度决定了频谱图中有多少个频率仓。


在此实现中，假设窗口被零填充以具有与分析帧相同的大小。 A
填充窗口可以从
 `窗口函数()`
 。 FFT输入缓冲区可能大于分析帧，
通常是 2 的下一个幂。


注意：此功能尚未针对速度进行优化。它应该大部分兼容
 `librosa.stft`
 和
 `torchaudio.function.transforms.Spectrogram`
 ，尽管由于频谱图的不同方式而更加灵活
可以构建。




#### 


Transformers.audio\_utils.power\_to\_db


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L479)


（


 频谱图
 
 ：ndarray


参考
 
 ：浮动= 1.0


最小值\_值
 
 : 浮点数 = 1e-10


数据库\_范围
 
 : 打字.可选[浮点] = 无


）
 

 →


导出常量元数据='未定义';
 

`np.ndarray`


 参数


* **频谱图**
 （
 `np.ndarray`
 )—
输入功率 (mel) 频谱图。请注意，功率谱图具有振幅的平方！
* **参考**
 （
 `浮动`
 ,
 *选修的*
 ，默认为 1.0) —
设置对应于 0 dB 的输入频谱图值。例如，使用
 `np.max(频谱图)`
 设置
最大声部分为 0 dB。必须大于零。
* **最小值\_值**
 （
 `浮动`
 ,
 *选修的*
 ，默认为
 `1e-10`
 )—
在转换为分贝之前，频谱图将被剪切到该最小值，以避免
 `日志(0)`
 。默认为
 `1e-10`
 对应于最小值 -100 dB。必须大于零。
* **db\_range**
 （
 `浮动`
 ,
 *选修的*
 )—
设置最大动态范围（以分贝为单位）。例如，如果
 `db_range = 80`
 ，之间的差异
峰值和最小值绝不会超过80 dB。必须大于零。


退货


导出常量元数据='未定义';
 

`np.ndarray`


导出常量元数据='未定义';


以分贝为单位的频谱图


将功率谱图转换为分贝标度。这计算
 `10 * log10（频谱图/参考）`
 ，使用基本的
数值稳定性的对数特性。


在（梅尔）频谱图上应用对数函数的动机是，人类听不到响度
线性刻度。一般来说，为了使声音的感知音量加倍，我们需要投入 8 倍的能量。
这意味着如果声音一开始就很大，那么能量的巨大变化听起来可能不会有太大不同。
这种压缩操作使（梅尔）声谱图特征更接近人类实际听到的内容。


基于实施
 `librosa.power_to_db`
 。




#### 


Transformers.audio\_utils.amplitude\_to\_db


[<
 

 来源
 

 >](https://github.com/huggingface/transformers/blob/v4.35.2/src/transformers/audio_utils.py#L530)


（


 频谱图
 
 ：ndarray


参考
 
 ：浮动= 1.0


最小值\_值
 
 ：浮动= 1e-05


数据库\_范围
 
 : 打字.可选[浮点] = 无


）
 

 →


导出常量元数据='未定义';
 

`np.ndarray`


 参数


* **频谱图**
 （
 `np.ndarray`
 )—
输入幅度 (mel) 频谱图。
* **参考**
 （
 `浮动`
 ,
 *选修的*
 ，默认为 1.0) —
设置对应于 0 dB 的输入频谱图值。例如，使用
 `np.max(频谱图)`
 设置
最大声部分为 0 dB。必须大于零。
* **最小值\_值**
 （
 `浮动`
 ,
 *选修的*
 ，默认为
 `1e-5`
 )—
在转换为分贝之前，频谱图将被剪切到该最小值，以避免
 `日志(0)`
 。默认为
 `1e-5`
 对应于最小值 -100 dB。必须大于零。
* **db\_range**
 （
 `浮动`
 ,
 *选修的*
 )—
设置最大动态范围（以分贝为单位）。例如，如果
 `db_range = 80`
 ，之间的差异
峰值和最小值绝不会超过80 dB。必须大于零。


退货


导出常量元数据='未定义';
 

`np.ndarray`


导出常量元数据='未定义';


以分贝为单位的频谱图


将幅度频谱图转换为分贝标度。这计算
 `20 * log10(频谱图/参考)`
 ， 使用
数值稳定性的基本对数特性。


在（梅尔）频谱图上应用对数函数的动机是，人类听不到响度
线性刻度。一般来说，为了使声音的感知音量加倍，我们需要投入 8 倍的能量。
这意味着如果声音一开始就很大，那么能量的巨大变化听起来可能不会有太大不同。
这种压缩操作使（梅尔）声谱图特征更接近人类实际听到的内容。